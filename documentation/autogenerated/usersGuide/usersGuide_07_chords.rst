.. _usersGuide_07_chords:

.. WARNING: DO NOT EDIT THIS FILE:
   AUTOMATICALLY GENERATED.
   PLEASE EDIT THE .py FILE DIRECTLY.


User's Guide, Chapter 7: Chords
===============================

Chords, as the name might suggest, are objects that combine multiple
:class:`~music21.pitch.Pitch` objects on a single stem. They can be
found in the :ref:`moduleChord` module. The most general way to create
a :class:`~music21.chord.Chord` object is by passing in a list of
pitch names you want in the chord:

.. code:: ipython3

    from music21 import *
    cMinor = chord.Chord(["C4","G4","E-5"]) 

``Note`` and ``Chord`` objects, since both are subclasses of the
:class:`~music21.note.GeneralNote` object share many features in
common:

.. code:: ipython3

    cMinor.duration.type = 'half'
    cMinor.quarterLength




.. parsed-literal::
   :class: ipython-result

    2.0



But since a ``Chord`` contains many pitches, it does not have a
``.pitch`` attribute:

.. code:: ipython3

    cMinor.pitch


::


    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    <ipython-input-3-682233136f94> in <module>()
    ----> 1 cMinor.pitch
    

    AttributeError: 'Chord' object has no attribute 'pitch'


Instead it has a :meth:`.pitches <music21.chord.Chord.pitches>`
attribute which returns a Tuple of pitches in the Chord.

.. code:: ipython3

    cMinor.pitches




.. parsed-literal::
   :class: ipython-result

    (<music21.pitch.Pitch C4>, <music21.pitch.Pitch G4>, <music21.pitch.Pitch E-5>)



A little bit more about Python. ``.pitches`` returns a tuple, what's
that? A tuple is like a list, except that unlike a list which has square
brackets around it, a tuple has parentheses around it:

.. code:: ipython3

    baroqueTuple = ('Bach', 'Handel', 'Telemann')
    classicalList = ['Mozart', 'Haydn', 'Beethoven']
    
    baroqueTuple




.. parsed-literal::
   :class: ipython-result

    ('Bach', 'Handel', 'Telemann')



.. code:: ipython3

    classicalList




.. parsed-literal::
   :class: ipython-result

    ['Mozart', 'Haydn', 'Beethoven']



Both tuples and lists can find members by accessing them with numbers in
square brackets:

.. code:: ipython3

    baroqueTuple[0]




.. parsed-literal::
   :class: ipython-result

    'Bach'



.. code:: ipython3

    classicalList[0]




.. parsed-literal::
   :class: ipython-result

    'Mozart'



But the biggest difference between the two is that you can manipulate a
list, but not a tuple. If we try to add someone to the classicalList,
using ``.append`` it works great.

.. code:: ipython3

    classicalList.append('Ella Fitzgerald') # she's a classic to me...
    
    classicalList




.. parsed-literal::
   :class: ipython-result

    ['Mozart', 'Haydn', 'Beethoven', 'Ella Fitzgerald']



.. code:: ipython3

    classicalList.remove('Mozart')
    
    classicalList




.. parsed-literal::
   :class: ipython-result

    ['Haydn', 'Beethoven', 'Ella Fitzgerald']



But a tuple can't be changed:

.. code:: ipython3

    baroqueTuple.append('Miles Davis')


::


    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    <ipython-input-11-2e49d4b97491> in <module>()
    ----> 1 baroqueTuple.append('Miles Davis')
    

    AttributeError: 'tuple' object has no attribute 'append'


In this case, that's a shame, because Miles belongs with Bach! So we
shouldn't have used a tuple there.

But in the class of ``.pitches`` it makes sense that it returns a tuple,
since changing the result ``.pitches`` separate from the Chord could be
ambiguous -- did you mean to change the result of ``.pitches`` or to
change the pitches in the chord itself? ``music21`` will often return
tuples in places where manipulating the result could cause headaches or
bugs down the line. In any case, it's easy to turn a tuple into a list
or vice versa:

.. code:: ipython3

    baroqueList = list(baroqueTuple)
    baroqueList.append('Miles Davis')
    baroqueList




.. parsed-literal::
   :class: ipython-result

    ['Bach', 'Handel', 'Telemann', 'Miles Davis']



.. code:: ipython3

    classicalTuple = tuple(classicalList)
    classicalTuple




.. parsed-literal::
   :class: ipython-result

    ('Haydn', 'Beethoven', 'Ella Fitzgerald')



Okay, back to chord, where we left off:

.. code:: ipython3

    cMinor.pitches




.. parsed-literal::
   :class: ipython-result

    (<music21.pitch.Pitch C4>, <music21.pitch.Pitch G4>, <music21.pitch.Pitch E-5>)



But you already knew what pitches were in the ``Chord`` since you just
created it! What else can you do with it?

How about determining if it is a
:meth:`major <music21.chord.Chord.isMajorTriad>` or a
:meth:`minor <music21.chord.Chord.isMinorTriad>` triad?

.. code:: ipython3

    cMinor.isMajorTriad()




.. parsed-literal::
   :class: ipython-result

    False



.. code:: ipython3

    cMinor.isMinorTriad()




.. parsed-literal::
   :class: ipython-result

    True



You can also figure out if it is in inversion or not:

.. code:: ipython3

    cMinor.inversion()




.. parsed-literal::
   :class: ipython-result

    0



Chords in root position have inversion of 0. But consider this other
chord:

.. code:: ipython3

    cMajor = chord.Chord(["E3","C4","G4"])
    cMajor.inversion()




.. parsed-literal::
   :class: ipython-result

    1



With this chord, two other methods become important:

.. code:: ipython3

    cMajor.root()




.. parsed-literal::
   :class: ipython-result

    <music21.pitch.Pitch C4>



.. code:: ipython3

    cMajor.bass()




.. parsed-literal::
   :class: ipython-result

    <music21.pitch.Pitch E3>



You can find the third and fifth of the ``Chord`` with .third and
.fifth. Note that these properties do not have ``()`` after them. This
was a mistake in how we created ``music21`` and hopefully this will all
be fixed and consistent soon:

.. code:: ipython3

    cMajor.third




.. parsed-literal::
   :class: ipython-result

    <music21.pitch.Pitch E3>



.. code:: ipython3

    cMajor.fifth




.. parsed-literal::
   :class: ipython-result

    <music21.pitch.Pitch G4>



There is also a .seventh property, but it won't do anything here:

.. code:: ipython3

    cMajor.seventh

The result of that is ``None`` which we can test like so...

.. code:: ipython3

    cMajor.seventh is None




.. parsed-literal::
   :class: ipython-result

    True



We can (as of v.4) append or remove notes from a chord, just like in a
list:

.. code:: ipython3

    dMaj = chord.Chord('D4 F#4')
    dMaj.append('A5')
    dMaj




.. parsed-literal::
   :class: ipython-result

    <music21.chord.Chord D4 F#4 A5>



.. code:: ipython3

    dMaj.remove('D4')
    dMaj




.. parsed-literal::
   :class: ipython-result

    <music21.chord.Chord F#4 A5>



.. code:: ipython3

    dMaj.append(pitch.Pitch('D3'))
    dMaj.append(note.Note('F#5'))
    dMaj




.. parsed-literal::
   :class: ipython-result

    <music21.chord.Chord D3 F#4 F#5 A5>



Displaying Chords
-----------------

We can display the ``Chord`` object just like any
:class:`~music21.note.Note` (Don't worry if this isn't working for you
yet...we'll get this set up in Chapter 8)

.. code:: ipython3

    cMinor.show()



.. image:: usersGuide_07_chords_48_0.png
   :width: 144px
   :height: 54px


.. code:: ipython3

    cMajor.show()



.. image:: usersGuide_07_chords_49_0.png
   :width: 137px
   :height: 67px


These chords are a bit "spacey", so let's get ``c`` in
:meth:`~music21.chord.Chord.closedPosition`:

.. code:: ipython3

    cClosed = cMinor.closedPosition()
    cClosed.show()



.. image:: usersGuide_07_chords_51_0.png
   :width: 144px
   :height: 49px


Notice that ``cMinor`` is unchanged. The closed position chord is only
``cClosed``:

.. code:: ipython3

    cMinor.show()



.. image:: usersGuide_07_chords_53_0.png
   :width: 144px
   :height: 54px


If we wanted to change the Chord object itself, we call
``.closedPosition(inPlace=True)`` which alters the original. Since the
original is altered, we don't need to put ``x = ...`` in front of it

.. code:: ipython3

    cMajor.closedPosition(inPlace=True)
    cMajor.show()



.. image:: usersGuide_07_chords_55_0.png
   :width: 138px
   :height: 45px


There is also a method,
:meth:`~music21.chord.Chord.semiClosedPosition` which acts like
``.closedPosition`` except that if there is already a pitch at that step
(i.e., D-flat and D-sharp are both step "D"), then the note is moved up
an octave. This is useful for displaying complex, post tonal chords in
the most compact form possible:

.. code:: ipython3

    c1 = chord.Chord(['C4', 'E5', 'C#6', 'E-7', 'G8', 'C9', 'E#9'])
    c2 = c1.semiClosedPosition()
    c2.show()



.. image:: usersGuide_07_chords_57_0.png
   :width: 167px
   :height: 82px


We can get the :meth:`common name <music21.chord.Chord.commonName>` of
each of these Chords:

.. code:: ipython3

    cn1 = cMinor.commonName
    print(cn1)


.. parsed-literal::
   :class: ipython-result

    minor triad


.. code:: ipython3

    print(cMajor.commonName)


.. parsed-literal::
   :class: ipython-result

    major triad


More complex chords have less common "commonNames". Here's one that the
American composer Elliott Carter liked a lot.

.. code:: ipython3

    elliottCarterChord = chord.Chord(['C4','D-4','E4','F#4'])
    elliottCarterChord.commonName




.. parsed-literal::
   :class: ipython-result

    'all-interval tetrachord'



.. code:: ipython3

    elliottCarterChord.show()



.. image:: usersGuide_07_chords_63_0.png
   :width: 178px
   :height: 50px


More ways of creating chords; Chords and Streams
------------------------------------------------

There are other ways of creating a Chord if you'd like. One way is from
a bunch of already created ``Note`` objects:

.. code:: ipython3

    d = note.Note('D4')
    fSharp = note.Note('F#4')
    a = note.Note('A5')
    dMajor = chord.Chord([d, fSharp, a])
    
    dMajor.show()



.. image:: usersGuide_07_chords_66_0.png
   :width: 146px
   :height: 60px


Or we can pass a string with note names separated by spaces:

.. code:: ipython3

    e7 = chord.Chord("E4 G#4 B4 D5")
    e7.show()



.. image:: usersGuide_07_chords_68_0.png
   :width: 146px
   :height: 51px


The octaves are optional, especially if everything is within an octave:

.. code:: ipython3

    es = chord.Chord("E- G B-")
    es.show()



.. image:: usersGuide_07_chords_70_0.png
   :width: 150px
   :height: 49px


But you will definitely want them if a chord crosses the boundary of an
octave (between B and C). Unless you love 6-4 chords, this is probably
not what you want:

.. code:: ipython3

    fMajor = chord.Chord("F A C")
    fMajor.show()



.. image:: usersGuide_07_chords_72_0.png
   :width: 137px
   :height: 50px


Notice that because C sorts before F and A that the chord is in second
inversion, or 64. We can figure out the inversion of a ``Chord`` like
so:

.. code:: ipython3

    print(fMajor.inversion(), fMajor.inversionName())


.. parsed-literal::
   :class: ipython-result

    2 64


In addition to .commonName, there are a few other "name" properties that
might be interesting:

.. code:: ipython3

    fMajor.fullName




.. parsed-literal::
   :class: ipython-result

    'Chord {F | A | C} Quarter'



.. code:: ipython3

    fMajor.pitchedCommonName




.. parsed-literal::
   :class: ipython-result

    'F-major triad'



Like ``Note`` objects, we can put ``Chord`` objects inside a
:class:`~music21.stream.Stream`:

.. code:: ipython3

    stream1 = stream.Stream()
    stream1.append(cMinor)
    stream1.append(fMajor)
    stream1.append(es)
    stream1.show()



.. image:: usersGuide_07_chords_79_0.png
   :width: 236px
   :height: 54px


We can mix and match ``Notes``, :class:`Rests <music21.note.Rest>`,
and ``Chords``:

.. code:: ipython3

    rest1 = note.Rest()
    rest1.quarterLength = 0.5
    noteASharp = note.Note('A#5')
    noteASharp.quarterLength = 1.5
    
    stream2 = stream.Stream()
    stream2.append(cMinor)
    stream2.append(rest1)
    stream2.append(noteASharp)
    stream2.show()



.. image:: usersGuide_07_chords_81_0.png
   :width: 231px
   :height: 55px


Post-tonal chords (in brief)
----------------------------

There are a lot of methods for dealing with post-tonal aspects of
chords. If you're not interested in twentieth century music, go ahead
and skip to the next chapter, but, here are some fun things.

The ``intervalVector`` of a chord is a list of the number of
``[semitones, whole-tones, minor-thirds/augmented-seconds, major-thirds, perfect fourths, and tritones]``
in the chord or inversion. A minor triad, for instance, has one minor
third (C to E-flat), one major third (E-flat to G), and one perfect
fourth (G to C above, since octave does not matter):

.. code:: ipython3

    cMinor.intervalVector




.. parsed-literal::
   :class: ipython-result

    [0, 0, 1, 1, 1, 0]



A major triad has the same interval vector:

.. code:: ipython3

    cMajor.intervalVector




.. parsed-literal::
   :class: ipython-result

    [0, 0, 1, 1, 1, 0]



The elliottCarterChord is unique in that it has an ``.intervalVector``
of all 1's:

.. code:: ipython3

    elliottCarterChord.intervalVector




.. parsed-literal::
   :class: ipython-result

    [1, 1, 1, 1, 1, 1]



Well, it's almost unique: there is another chord with the same
``.intervalVector``. That Chord is called its Z-relation or Z-pair.

.. code:: ipython3

    elliottCarterChord.hasZRelation




.. parsed-literal::
   :class: ipython-result

    True



.. code:: ipython3

    otherECChord = elliottCarterChord.getZRelation()
    otherECChord




.. parsed-literal::
   :class: ipython-result

    <music21.chord.Chord C D- E- G>



.. code:: ipython3

    otherECChord.show()



.. image:: usersGuide_07_chords_92_0.png
   :width: 194px
   :height: 56px


.. code:: ipython3

    otherECChord.intervalVector




.. parsed-literal::
   :class: ipython-result

    [1, 1, 1, 1, 1, 1]



The other post-tonal tools you might be interested in are given below.
We'll return to them in a later chapter, but here are three important
ones:

.. code:: ipython3

    print(elliottCarterChord.primeForm)


.. parsed-literal::
   :class: ipython-result

    [0, 1, 4, 6]


.. code:: ipython3

    print(elliottCarterChord.normalOrder)


.. parsed-literal::
   :class: ipython-result

    [0, 1, 4, 6]


.. code:: ipython3

    print(elliottCarterChord.forteClass)


.. parsed-literal::
   :class: ipython-result

    4-15A


If you really only care about semitones, you can create a chord just
with the pitchClasses:

.. code:: ipython3

    oddChord = chord.Chord([1, 3, 7, 9, 10])
    oddChord.show()



.. image:: usersGuide_07_chords_99_0.png
   :width: 224px
   :height: 56px


There's a little problem with the A and A# being on the same space that
makes it hard to read. Let's flip the A# to Bb:

.. code:: ipython3

    oddChord.pitches[-1].getHigherEnharmonic(inPlace=True)
    oddChord.show()



.. image:: usersGuide_07_chords_101_0.png
   :width: 209px
   :height: 56px


If you use pitchClasses above 11, then they are treated as MIDI numbers,
where 60 = MiddleC, 72 = C5, etc. Enharmonic spelling is chosen
automatically.

.. code:: ipython3

    midiChordType = chord.Chord([60, 65, 70, 75])
    midiChordType.show()



.. image:: usersGuide_07_chords_103_0.png
   :width: 163px
   :height: 61px


Okay, so now you've learned the basics (and more!) of Notes and Chords.
If you haven't been able to see them on your own,
:ref:`Chapter 8: Installing MusicXML Readers <usersGuide_08_installingMusicXML>`
will fix it. It's also going to cover the basic file formats of
``music21``.